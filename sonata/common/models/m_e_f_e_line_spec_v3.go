// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MEFELineSpecV3 ELineSpec
//
// Description of ELineSpec for Ordering - source 57.1
//
// swagger:model mEFELineSpecV3
type MEFELineSpecV3 struct {

	// The ingress bandwidth profile at ENNI
	ENNIIngressBWProfile []*BandwidthProfile `json:"ENNIIngressBWProfile"`

	// The ingress bandwidth profile at UNI
	UNIIngressBWProfile []*BandwidthProfile `json:"UNIIngressBWProfile"`

	// The name of the designation given to one or more sets of performance objectives and associated parameters by the Seller (e.g., “Gold”).
	ClassOfServiceName string `json:"classOfServiceName,omitempty"`

	// Color Forwarding is an OVC attribute defining the relationship between the color on an egress ENNI frame and the color of the corresponding ingress ENNI Frame or Service Frame. For ordering, this attribute identifies if the Buyer requests Color Forwarding
	ColorForwardingEnabled *bool `json:"colorForwardingEnabled,omitempty"`

	// Per MEF 26.2, the maximum frame size provides the upper bounds on the length of an ingress frame. An integer greater or equal to 1526.
	// Maximum: 1526
	MaximumFrameSize int32 `json:"maximumFrameSize,omitempty"`

	// The S-VLAN ID to be used for this service.
	SVlanID int32 `json:"sVlanId,omitempty"`
}

// Validate validates this m e f e line spec v3
func (m *MEFELineSpecV3) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateENNIIngressBWProfile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUNIIngressBWProfile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaximumFrameSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MEFELineSpecV3) validateENNIIngressBWProfile(formats strfmt.Registry) error {

	if swag.IsZero(m.ENNIIngressBWProfile) { // not required
		return nil
	}

	for i := 0; i < len(m.ENNIIngressBWProfile); i++ {
		if swag.IsZero(m.ENNIIngressBWProfile[i]) { // not required
			continue
		}

		if m.ENNIIngressBWProfile[i] != nil {
			if err := m.ENNIIngressBWProfile[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ENNIIngressBWProfile" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MEFELineSpecV3) validateUNIIngressBWProfile(formats strfmt.Registry) error {

	if swag.IsZero(m.UNIIngressBWProfile) { // not required
		return nil
	}

	for i := 0; i < len(m.UNIIngressBWProfile); i++ {
		if swag.IsZero(m.UNIIngressBWProfile[i]) { // not required
			continue
		}

		if m.UNIIngressBWProfile[i] != nil {
			if err := m.UNIIngressBWProfile[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("UNIIngressBWProfile" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MEFELineSpecV3) validateMaximumFrameSize(formats strfmt.Registry) error {

	if swag.IsZero(m.MaximumFrameSize) { // not required
		return nil
	}

	if err := validate.MaximumInt("maximumFrameSize", "body", int64(m.MaximumFrameSize), 1526, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MEFELineSpecV3) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MEFELineSpecV3) UnmarshalBinary(b []byte) error {
	var res MEFELineSpecV3
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
