// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GeographicSubAddress It is used for addressing within a property in an urban area (country properties are often defined differently). It may refer to a building, a building cluster, or a floor of a multistory building.
//
// swagger:model GeographicSubAddress
type GeographicSubAddress struct {

	// Technical attribute to exend this class if needed (JSON schema locator)
	AtSchemaLocation string `json:"@schemaLocation,omitempty"`

	// When sub-classing, this defines the sub-class entity name
	AtType string `json:"@type,omitempty"`

	// Allows for buildings that have well-known names
	// Max Length: 60
	BuildingName string `json:"buildingName,omitempty"`

	// Unique Identifier of the subAddress
	ID string `json:"id,omitempty"`

	// Used where a level type may be repeated e.g. BASEMENT 1, BASEMENT 2
	// Max Length: 25
	LevelNumber string `json:"levelNumber,omitempty"`

	// Describes level types within a building
	// Max Length: 25
	LevelType string `json:"levelType,omitempty"`

	// "Private streets internal to a property (e.g. a university) may have internal names that are not recorded by the land title office
	// Max Length: 60
	PrivateStreetName string `json:"privateStreetName,omitempty"`

	// Private streets numbers internal to a private street
	// Max Length: 10
	PrivateStreetNumber string `json:"privateStreetNumber,omitempty"`

	// sub unit
	SubUnit []*SubUnit `json:"subUnit"`
}

// Validate validates this geographic sub address
func (m *GeographicSubAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildingName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLevelNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLevelType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivateStreetName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivateStreetNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GeographicSubAddress) validateBuildingName(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildingName) { // not required
		return nil
	}

	if err := validate.MaxLength("buildingName", "body", string(m.BuildingName), 60); err != nil {
		return err
	}

	return nil
}

func (m *GeographicSubAddress) validateLevelNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.LevelNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("levelNumber", "body", string(m.LevelNumber), 25); err != nil {
		return err
	}

	return nil
}

func (m *GeographicSubAddress) validateLevelType(formats strfmt.Registry) error {

	if swag.IsZero(m.LevelType) { // not required
		return nil
	}

	if err := validate.MaxLength("levelType", "body", string(m.LevelType), 25); err != nil {
		return err
	}

	return nil
}

func (m *GeographicSubAddress) validatePrivateStreetName(formats strfmt.Registry) error {

	if swag.IsZero(m.PrivateStreetName) { // not required
		return nil
	}

	if err := validate.MaxLength("privateStreetName", "body", string(m.PrivateStreetName), 60); err != nil {
		return err
	}

	return nil
}

func (m *GeographicSubAddress) validatePrivateStreetNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.PrivateStreetNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("privateStreetNumber", "body", string(m.PrivateStreetNumber), 10); err != nil {
		return err
	}

	return nil
}

func (m *GeographicSubAddress) validateSubUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.SubUnit) { // not required
		return nil
	}

	for i := 0; i < len(m.SubUnit); i++ {
		if swag.IsZero(m.SubUnit[i]) { // not required
			continue
		}

		if m.SubUnit[i] != nil {
			if err := m.SubUnit[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("subUnit" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *GeographicSubAddress) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GeographicSubAddress) UnmarshalBinary(b []byte) error {
	var res GeographicSubAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
