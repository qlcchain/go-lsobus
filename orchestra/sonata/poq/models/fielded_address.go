// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FieldedAddress A type of Address that has a discrete field and value for each type of boundary or identifier down to the lowest level of detail. For example “street number” is one field, “street name” is another field, etc.
//
// swagger:model FieldedAddress
type FieldedAddress struct {
	atReferredTypeField string

	hrefField string

	idField string

	roleField *string

	// The city that the address is in
	// Required: true
	// Max Length: 50
	City *string `json:"city"`

	// Country that the address is in
	// Required: true
	// Max Length: 50
	Country *string `json:"country"`

	// geographic sub address
	GeographicSubAddress *GeographicSubAddress `json:"geographicSubAddress,omitempty"`

	// The locality that the address is in
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Descriptor for a postal delivery area, used to speed and simplify the delivery of mail (also known as zipcode)
	// Required: true
	// Max Length: 6
	Postcode *string `json:"postcode"`

	// An extension of a postal code. E.g. the part following the dash in an american urban property address
	// Max Length: 4
	PostcodeExtension string `json:"postcodeExtension,omitempty"`

	// The State or Province that the address is in
	// Required: true
	// Max Length: 50
	StateOrProvince *string `json:"stateOrProvince"`

	// Name of the street or other street type
	// Max Length: 60
	StreetName string `json:"streetName,omitempty"`

	// Number identifying a specific property on a public street. It may be combined with streetNrLast for ranged addresses
	// Max Length: 10
	StreetNr string `json:"streetNr,omitempty"`

	// Last number in a range of street numbers allocated to a property
	// Max Length: 10
	StreetNrLast string `json:"streetNrLast,omitempty"`

	// Last street number suffix for a ranged address
	// Max Length: 10
	StreetNrLastSuffix string `json:"streetNrLastSuffix,omitempty"`

	// The first street number suffix
	// Max Length: 10
	StreetNrSuffix string `json:"streetNrSuffix,omitempty"`

	// A modifier denoting a relative direction
	// Max Length: 2
	StreetSuffix string `json:"streetSuffix,omitempty"`

	// Alley, avenue, boulevard, brae, crescent, drive, highway, lane, terrace, parade, place, tarn, way, wharf
	// Required: true
	// Max Length: 25
	StreetType *string `json:"streetType"`
}

// AtReferredType gets the at referred type of this subtype
func (m *FieldedAddress) AtReferredType() string {
	return m.atReferredTypeField
}

// SetAtReferredType sets the at referred type of this subtype
func (m *FieldedAddress) SetAtReferredType(val string) {
	m.atReferredTypeField = val
}

// AtType gets the at type of this subtype
func (m *FieldedAddress) AtType() string {
	return "FieldedAddress"
}

// SetAtType sets the at type of this subtype
func (m *FieldedAddress) SetAtType(val string) {
}

// Href gets the href of this subtype
func (m *FieldedAddress) Href() string {
	return m.hrefField
}

// SetHref sets the href of this subtype
func (m *FieldedAddress) SetHref(val string) {
	m.hrefField = val
}

// ID gets the id of this subtype
func (m *FieldedAddress) ID() string {
	return m.idField
}

// SetID sets the id of this subtype
func (m *FieldedAddress) SetID(val string) {
	m.idField = val
}

// Role gets the role of this subtype
func (m *FieldedAddress) Role() *string {
	return m.roleField
}

// SetRole sets the role of this subtype
func (m *FieldedAddress) SetRole(val *string) {
	m.roleField = val
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *FieldedAddress) UnmarshalJSON(raw []byte) error {
	var data struct {

		// The city that the address is in
		// Required: true
		// Max Length: 50
		City *string `json:"city"`

		// Country that the address is in
		// Required: true
		// Max Length: 50
		Country *string `json:"country"`

		// geographic sub address
		GeographicSubAddress *GeographicSubAddress `json:"geographicSubAddress,omitempty"`

		// The locality that the address is in
		// Max Length: 50
		Locality string `json:"locality,omitempty"`

		// Descriptor for a postal delivery area, used to speed and simplify the delivery of mail (also known as zipcode)
		// Required: true
		// Max Length: 6
		Postcode *string `json:"postcode"`

		// An extension of a postal code. E.g. the part following the dash in an american urban property address
		// Max Length: 4
		PostcodeExtension string `json:"postcodeExtension,omitempty"`

		// The State or Province that the address is in
		// Required: true
		// Max Length: 50
		StateOrProvince *string `json:"stateOrProvince"`

		// Name of the street or other street type
		// Max Length: 60
		StreetName string `json:"streetName,omitempty"`

		// Number identifying a specific property on a public street. It may be combined with streetNrLast for ranged addresses
		// Max Length: 10
		StreetNr string `json:"streetNr,omitempty"`

		// Last number in a range of street numbers allocated to a property
		// Max Length: 10
		StreetNrLast string `json:"streetNrLast,omitempty"`

		// Last street number suffix for a ranged address
		// Max Length: 10
		StreetNrLastSuffix string `json:"streetNrLastSuffix,omitempty"`

		// The first street number suffix
		// Max Length: 10
		StreetNrSuffix string `json:"streetNrSuffix,omitempty"`

		// A modifier denoting a relative direction
		// Max Length: 2
		StreetSuffix string `json:"streetSuffix,omitempty"`

		// Alley, avenue, boulevard, brae, crescent, drive, highway, lane, terrace, parade, place, tarn, way, wharf
		// Required: true
		// Max Length: 25
		StreetType *string `json:"streetType"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var base struct {
		/* Just the base type fields. Used for unmashalling polymorphic types.*/

		AtReferredType string `json:"@referredType,omitempty"`

		AtType string `json:"@type,omitempty"`

		Href string `json:"href,omitempty"`

		ID string `json:"id,omitempty"`

		Role *string `json:"role"`
	}
	buf = bytes.NewBuffer(raw)
	dec = json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&base); err != nil {
		return err
	}

	var result FieldedAddress

	result.atReferredTypeField = base.AtReferredType

	if base.AtType != result.AtType() {
		/* Not the type we're looking for. */
		return errors.New(422, "invalid @type value: %q", base.AtType)
	}
	result.hrefField = base.Href

	result.idField = base.ID

	result.roleField = base.Role

	result.City = data.City
	result.Country = data.Country
	result.GeographicSubAddress = data.GeographicSubAddress
	result.Locality = data.Locality
	result.Postcode = data.Postcode
	result.PostcodeExtension = data.PostcodeExtension
	result.StateOrProvince = data.StateOrProvince
	result.StreetName = data.StreetName
	result.StreetNr = data.StreetNr
	result.StreetNrLast = data.StreetNrLast
	result.StreetNrLastSuffix = data.StreetNrLastSuffix
	result.StreetNrSuffix = data.StreetNrSuffix
	result.StreetSuffix = data.StreetSuffix
	result.StreetType = data.StreetType

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m FieldedAddress) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {

		// The city that the address is in
		// Required: true
		// Max Length: 50
		City *string `json:"city"`

		// Country that the address is in
		// Required: true
		// Max Length: 50
		Country *string `json:"country"`

		// geographic sub address
		GeographicSubAddress *GeographicSubAddress `json:"geographicSubAddress,omitempty"`

		// The locality that the address is in
		// Max Length: 50
		Locality string `json:"locality,omitempty"`

		// Descriptor for a postal delivery area, used to speed and simplify the delivery of mail (also known as zipcode)
		// Required: true
		// Max Length: 6
		Postcode *string `json:"postcode"`

		// An extension of a postal code. E.g. the part following the dash in an american urban property address
		// Max Length: 4
		PostcodeExtension string `json:"postcodeExtension,omitempty"`

		// The State or Province that the address is in
		// Required: true
		// Max Length: 50
		StateOrProvince *string `json:"stateOrProvince"`

		// Name of the street or other street type
		// Max Length: 60
		StreetName string `json:"streetName,omitempty"`

		// Number identifying a specific property on a public street. It may be combined with streetNrLast for ranged addresses
		// Max Length: 10
		StreetNr string `json:"streetNr,omitempty"`

		// Last number in a range of street numbers allocated to a property
		// Max Length: 10
		StreetNrLast string `json:"streetNrLast,omitempty"`

		// Last street number suffix for a ranged address
		// Max Length: 10
		StreetNrLastSuffix string `json:"streetNrLastSuffix,omitempty"`

		// The first street number suffix
		// Max Length: 10
		StreetNrSuffix string `json:"streetNrSuffix,omitempty"`

		// A modifier denoting a relative direction
		// Max Length: 2
		StreetSuffix string `json:"streetSuffix,omitempty"`

		// Alley, avenue, boulevard, brae, crescent, drive, highway, lane, terrace, parade, place, tarn, way, wharf
		// Required: true
		// Max Length: 25
		StreetType *string `json:"streetType"`
	}{

		City: m.City,

		Country: m.Country,

		GeographicSubAddress: m.GeographicSubAddress,

		Locality: m.Locality,

		Postcode: m.Postcode,

		PostcodeExtension: m.PostcodeExtension,

		StateOrProvince: m.StateOrProvince,

		StreetName: m.StreetName,

		StreetNr: m.StreetNr,

		StreetNrLast: m.StreetNrLast,

		StreetNrLastSuffix: m.StreetNrLastSuffix,

		StreetNrSuffix: m.StreetNrSuffix,

		StreetSuffix: m.StreetSuffix,

		StreetType: m.StreetType,
	})
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		AtReferredType string `json:"@referredType,omitempty"`

		AtType string `json:"@type,omitempty"`

		Href string `json:"href,omitempty"`

		ID string `json:"id,omitempty"`

		Role *string `json:"role"`
	}{

		AtReferredType: m.AtReferredType(),

		AtType: m.AtType(),

		Href: m.Href(),

		ID: m.ID(),

		Role: m.Role(),
	})
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this fielded address
func (m *FieldedAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRole(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeographicSubAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostcode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostcodeExtension(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStateOrProvince(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreetName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreetNr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreetNrLast(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreetNrLastSuffix(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreetNrSuffix(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreetSuffix(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreetType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FieldedAddress) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID()) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", string(m.ID()), 45); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateRole(formats strfmt.Registry) error {

	if err := validate.Required("role", "body", m.Role()); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateCity(formats strfmt.Registry) error {

	if err := validate.Required("city", "body", m.City); err != nil {
		return err
	}

	if err := validate.MaxLength("city", "body", string(*m.City), 50); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateCountry(formats strfmt.Registry) error {

	if err := validate.Required("country", "body", m.Country); err != nil {
		return err
	}

	if err := validate.MaxLength("country", "body", string(*m.Country), 50); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateGeographicSubAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.GeographicSubAddress) { // not required
		return nil
	}

	if m.GeographicSubAddress != nil {
		if err := m.GeographicSubAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("geographicSubAddress")
			}
			return err
		}
	}

	return nil
}

func (m *FieldedAddress) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(m.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("locality", "body", string(m.Locality), 50); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validatePostcode(formats strfmt.Registry) error {

	if err := validate.Required("postcode", "body", m.Postcode); err != nil {
		return err
	}

	if err := validate.MaxLength("postcode", "body", string(*m.Postcode), 6); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validatePostcodeExtension(formats strfmt.Registry) error {

	if swag.IsZero(m.PostcodeExtension) { // not required
		return nil
	}

	if err := validate.MaxLength("postcodeExtension", "body", string(m.PostcodeExtension), 4); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateStateOrProvince(formats strfmt.Registry) error {

	if err := validate.Required("stateOrProvince", "body", m.StateOrProvince); err != nil {
		return err
	}

	if err := validate.MaxLength("stateOrProvince", "body", string(*m.StateOrProvince), 50); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateStreetName(formats strfmt.Registry) error {

	if swag.IsZero(m.StreetName) { // not required
		return nil
	}

	if err := validate.MaxLength("streetName", "body", string(m.StreetName), 60); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateStreetNr(formats strfmt.Registry) error {

	if swag.IsZero(m.StreetNr) { // not required
		return nil
	}

	if err := validate.MaxLength("streetNr", "body", string(m.StreetNr), 10); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateStreetNrLast(formats strfmt.Registry) error {

	if swag.IsZero(m.StreetNrLast) { // not required
		return nil
	}

	if err := validate.MaxLength("streetNrLast", "body", string(m.StreetNrLast), 10); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateStreetNrLastSuffix(formats strfmt.Registry) error {

	if swag.IsZero(m.StreetNrLastSuffix) { // not required
		return nil
	}

	if err := validate.MaxLength("streetNrLastSuffix", "body", string(m.StreetNrLastSuffix), 10); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateStreetNrSuffix(formats strfmt.Registry) error {

	if swag.IsZero(m.StreetNrSuffix) { // not required
		return nil
	}

	if err := validate.MaxLength("streetNrSuffix", "body", string(m.StreetNrSuffix), 10); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateStreetSuffix(formats strfmt.Registry) error {

	if swag.IsZero(m.StreetSuffix) { // not required
		return nil
	}

	if err := validate.MaxLength("streetSuffix", "body", string(m.StreetSuffix), 2); err != nil {
		return err
	}

	return nil
}

func (m *FieldedAddress) validateStreetType(formats strfmt.Registry) error {

	if err := validate.Required("streetType", "body", m.StreetType); err != nil {
		return err
	}

	if err := validate.MaxLength("streetType", "body", string(*m.StreetType), 25); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FieldedAddress) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FieldedAddress) UnmarshalBinary(b []byte) error {
	var res FieldedAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
