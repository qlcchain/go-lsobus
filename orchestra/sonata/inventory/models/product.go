// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Product One or more services sold to a Buyer by a Seller.  A particular Product Offering defines the technical and commercial attributes and behav-iors of a Product.
//
// swagger:model Product
type Product struct {

	// the Base Type of the product if specialization.
	// This is a technical attribute to extend this class.
	AtBaseType string `json:"@baseType,omitempty"`

	// A pointer to a file describing extension attributes (if used).
	// This is a technical attribute to extend this class.
	AtSchemaLocation string `json:"@schemaLocation,omitempty"`

	// The type of product if specialization
	AtType string `json:"@type,omitempty"`

	// agreement
	Agreement []*Agreement `json:"agreement,omitempty"`

	// billing account
	BillingAccount []*BillingAccountRef `json:"billingAccount,omitempty"`

	// This identifier is optionally provided during the Product ordering and stored for informative purpose in the Seller inventory.
	BuyerProductID string `json:"buyerProductId,omitempty"`

	// Reference of the product (link)
	Href string `json:"href,omitempty"`

	// Unique identifier of the product in the product domain.
	// Required: true
	ID *string `json:"id"`

	// Latest date when the product has been updated
	// Format: date-time
	LastUpdateDate strfmt.DateTime `json:"lastUpdateDate,omitempty"`

	// product offering
	ProductOffering *ProductOfferingRef `json:"productOffering,omitempty"`

	// product order
	ProductOrder []*ProductOrderRef `json:"productOrder,omitempty"`

	// product price
	ProductPrice []*ProductPrice `json:"productPrice,omitempty"`

	// product relationship
	ProductRelationship []*ProductRelationship `json:"productRelationship,omitempty"`

	// product specification
	ProductSpecification *ProductSpecificationRef `json:"productSpecification,omitempty"`

	// product term
	ProductTerm []*ProductTerm `json:"productTerm,omitempty"`

	// related party
	RelatedParty []*RelatedParty `json:"relatedParty,omitempty"`

	// site
	Site []*GeographicSite `json:"site,omitempty"`

	// Start date is when the product is active for the first time (when the install in the product order has been processed).
	// Required: true
	// Format: date-time
	StartDate *strfmt.DateTime `json:"startDate,omitempty"`

	// status
	// Required: true
	Status ProductStatus `json:"status,omitempty"`

	// status change
	StatusChange []*StatusChange `json:"statusChange,omitempty"`

	// Termination date (commercial) is when the product has been terminated (when the disconnect in the product order has been processed).
	// Format: date-time
	TerminationDate strfmt.DateTime `json:"terminationDate,omitempty"`
}

// Validate validates this product
func (m *Product) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAgreement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillingAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductOffering(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductOrder(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductRelationship(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductSpecification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductTerm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRelatedParty(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSite(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusChange(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTerminationDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Product) validateAgreement(formats strfmt.Registry) error {

	if swag.IsZero(m.Agreement) { // not required
		return nil
	}

	for i := 0; i < len(m.Agreement); i++ {
		if swag.IsZero(m.Agreement[i]) { // not required
			continue
		}

		if m.Agreement[i] != nil {
			if err := m.Agreement[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("agreement" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateBillingAccount(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingAccount) { // not required
		return nil
	}

	for i := 0; i < len(m.BillingAccount); i++ {
		if swag.IsZero(m.BillingAccount[i]) { // not required
			continue
		}

		if m.BillingAccount[i] != nil {
			if err := m.BillingAccount[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("billingAccount" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateLastUpdateDate(formats strfmt.Registry) error {

	if swag.IsZero(m.LastUpdateDate) { // not required
		return nil
	}

	if err := validate.FormatOf("lastUpdateDate", "body", "date-time", m.LastUpdateDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateProductOffering(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductOffering) { // not required
		return nil
	}

	if m.ProductOffering != nil {
		if err := m.ProductOffering.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productOffering")
			}
			return err
		}
	}

	return nil
}

func (m *Product) validateProductOrder(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductOrder) { // not required
		return nil
	}

	for i := 0; i < len(m.ProductOrder); i++ {
		if swag.IsZero(m.ProductOrder[i]) { // not required
			continue
		}

		if m.ProductOrder[i] != nil {
			if err := m.ProductOrder[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("productOrder" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateProductPrice(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductPrice) { // not required
		return nil
	}

	for i := 0; i < len(m.ProductPrice); i++ {
		if swag.IsZero(m.ProductPrice[i]) { // not required
			continue
		}

		if m.ProductPrice[i] != nil {
			if err := m.ProductPrice[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("productPrice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateProductRelationship(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductRelationship) { // not required
		return nil
	}

	for i := 0; i < len(m.ProductRelationship); i++ {
		if swag.IsZero(m.ProductRelationship[i]) { // not required
			continue
		}

		if m.ProductRelationship[i] != nil {
			if err := m.ProductRelationship[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("productRelationship" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateProductSpecification(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductSpecification) { // not required
		return nil
	}

	if m.ProductSpecification != nil {
		if err := m.ProductSpecification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productSpecification")
			}
			return err
		}
	}

	return nil
}

func (m *Product) validateProductTerm(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductTerm) { // not required
		return nil
	}

	for i := 0; i < len(m.ProductTerm); i++ {
		if swag.IsZero(m.ProductTerm[i]) { // not required
			continue
		}

		if m.ProductTerm[i] != nil {
			if err := m.ProductTerm[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("productTerm" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateRelatedParty(formats strfmt.Registry) error {

	if swag.IsZero(m.RelatedParty) { // not required
		return nil
	}

	for i := 0; i < len(m.RelatedParty); i++ {
		if swag.IsZero(m.RelatedParty[i]) { // not required
			continue
		}

		if m.RelatedParty[i] != nil {
			if err := m.RelatedParty[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("relatedParty" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateSite(formats strfmt.Registry) error {

	if swag.IsZero(m.Site) { // not required
		return nil
	}

	for i := 0; i < len(m.Site); i++ {
		if swag.IsZero(m.Site[i]) { // not required
			continue
		}

		if m.Site[i] != nil {
			if err := m.Site[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("site" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateStartDate(formats strfmt.Registry) error {

	if err := validate.Required("startDate", "body", m.StartDate); err != nil {
		return err
	}

	if err := validate.FormatOf("startDate", "body", "date-time", m.StartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateStatus(formats strfmt.Registry) error {

	if err := m.Status.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("status")
		}
		return err
	}

	return nil
}

func (m *Product) validateStatusChange(formats strfmt.Registry) error {

	if swag.IsZero(m.StatusChange) { // not required
		return nil
	}

	for i := 0; i < len(m.StatusChange); i++ {
		if swag.IsZero(m.StatusChange[i]) { // not required
			continue
		}

		if m.StatusChange[i] != nil {
			if err := m.StatusChange[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("statusChange" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateTerminationDate(formats strfmt.Registry) error {

	if swag.IsZero(m.TerminationDate) { // not required
		return nil
	}

	if err := validate.FormatOf("terminationDate", "body", "date-time", m.TerminationDate.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Product) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Product) UnmarshalBinary(b []byte) error {
	var res Product
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
